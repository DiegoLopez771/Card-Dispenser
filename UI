//This code is meant to set the UI for the card dispenser
#include <Arduino.h>
#include <math.h>
#include <Wire.h>
#include <Adafruit_GFX.h>     //Handles High Level Graphics Communication
#include <Adafruit_SSD1306.h> //Handles I2C Hardware Communication

//=================================================================
//DEFINITIONS
//=================================================================
//Pin Definitions
#define _9switchPin     A0
#define _3rockerLeft    4
#define _3rockerRight   5
#define SCL             A5
#define SDA             A4
//Variable Definitions
#define screenWidth     128
#define screenHeight    64
#define OLED_RESET      -1      //Same as Arduino RESET button
#define OLED_ADDRESS    0x3C    //I2C Address for the OLED Screen

//OLED Screen Object
Adafruit_SSD1306 display(screenWidth, screenHeight, &Wire, OLED_RESET);

//=================================================================
//Global State Management
//=================================================================
enum AppState {
    SETUP_START,        //Initial Splash Screen
    SETUP_PLAYERS,      //Player Count Selection
    SETUP_MODE,         //Game Mode Selection
    CONFIG_COMPLETE     //Send to Nano
};

AppState currentState = SETUP_START;
//=================================================================
//Gloabal Variables
//=================================================================
int playerCount = 0;    //2 to 10
int gameMode = 0;       //1=UNO, 2=BJ, 3=Hold'em
const unsigned long selectTime = 5000; //5 seconds to select option
unsigned long lastSwitchTime = 0; //Time tracker for selection
const int startX = 5;
bool dispensingPhaseStarted = false;      // Flag to ensure dispensing screen is drawn once
bool configSent = false;                  // Flag to ensure config is sent once
// Variables to track the switch stability
int lastPlayerRead = -1;
int currentPlayerRead = -1;
int lastGameRead = -1;
int currentGameRead = -1;
//I2C Communication with Nano
const int nanoSlaveAddress = 0x09;

//=================================================================
//Switch Definition Arrays
//=================================================================
const int posToPlayerCount[9] = {2, 3, 4, 5, 6, 7, 8, 9, 10};
// ADC thresholds for the 9-position, equal-resistor ladder (assuming 1k Ohm resistors)
// We check from high-to-low resistance (Pin 9 to Pin 1)
const int ADCThresholds[9] = {
    966, // Pin 9
    852, // Pin 8
    738, // Pin 7
    625, // Pin 6
    511, // Pin 5
    397, // Pin 4
    284, // Pin 3
    170, // Pin 2
    56   // Pin 1
};

//=================================================================
//Function Declaration
//=================================================================
void countPlayers();
void gameModeSelected();
void drawPlayerSelectUI(int currentPlayers);
void drawGameSelectUI(int currentGame);
void drawConfigCompleteUI();
void drawDispensing();
void sendConfigToNano();

//=================================================================
//Setup and loop logic
//=================================================================
void setup(){
    //Set Pins
    pinMode(_9switchPin, INPUT);
    pinMode(_3rockerLeft, INPUT_PULLUP);
    pinMode(_3rockerRight, INPUT_PULLUP);
    Serial.begin(9600);
    Wire.begin();

    // I2C OLED Initialization
    //Change to 0x3D if doesn't work at first
    if(!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDRESS)) { 
        Serial.println(F("SSD1306 allocation failed. Check wiring/address."));
        for(;;); // Don't proceed if the display fails to start
    }
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(4, 28);
    display.println("Card Dispenser UI");
    display.display(); // Show the initial splash screen
    delay(2000);
    
    //Transition to the first setup state
    currentState = SETUP_PLAYERS;
}

void loop(){
    switch (currentState){
        case SETUP_PLAYERS:
            countPlayers();
            currentPlayerRead = playerCount;
            if(currentPlayerRead != lastPlayerRead){
                lastSwitchTime = millis();
                lastPlayerRead = currentPlayerRead;
            }
            drawPlayerSelectUI(playerCount);
            if(millis() - lastSwitchTime >= selectTime){
                currentState = SETUP_MODE;
                lastSwitchTime = millis();
                lastGameRead = -1; //Reset game read for next state
            }
            break;
            
        case SETUP_MODE:
            gameModeSelected();
            currentGameRead = gameMode;
            if(currentGameRead != lastGameRead){
                lastSwitchTime = millis();
                lastGameRead = currentGameRead;
            }
            drawGameSelectUI(gameMode);
            if(millis() - lastSwitchTime >= selectTime){
                currentState = CONFIG_COMPLETE;
                Serial.print("Game Mode Locked: ");
                Serial.println(gameMode);
                dispensingPhaseStarted = false; //Ensures we start at phase 1
                lastSwitchTime = millis();
            }
            break;
            
        case CONFIG_COMPLETE:
            if(!configSent) {
                sendConfigToNano();
            }

            if (!dispensingPhaseStarted) {
                drawConfigCompleteUI();
                if(millis() - lastSwitchTime >= 4000){ //Wait 4 seconds before dispensing
                    dispensingPhaseStarted = true;
                }
            }   else {
                drawDispensing();
            }
            break;
            
        default:
            // Should not happen, but safe to include
            currentState = SETUP_START;
            break;
    }
}

//=================================================================
//Functions
//=================================================================
//Reads the 9 pin rotary switch and determines the amount of players
void countPlayers(){
    int rawADC = analogRead(_9switchPin);
    for(int pos = 0; pos < 9; pos++){
        if(rawADC >= ADCThresholds[pos]){
            playerCount = posToPlayerCount[pos]; // Returns 2-10 players
            return;
        }
    }
    playerCount = 0; //Default to 0 players if reading is below the lowest threshold
}

//Reads the game mode selected by the 3 pin rocker switch
void gameModeSelected(){
    bool left = (digitalRead(_3rockerLeft) == LOW);
    bool right = (digitalRead(_3rockerRight) == LOW);

    if(left && !right){
        gameMode = 1; //Set for playing UNO
    } else if(!left && right){
        gameMode = 2; //Set for BlackJack
    } else {
        gameMode = 3; //Set for Texas Hold'em
    }
    currentGameRead = gameMode;
}

void drawPlayerSelectUI(int currentPlayers){
    display.clearDisplay();
    
    // Title Line (fixed)
    display.setTextSize(1);
    display.setCursor(5, 0); 
    display.println("Choose Player Count:");
    
    // Current Selection (large)
    display.setTextSize(3);
    display.setCursor(45, 25);
    display.print(currentPlayers);
    
    // Timeout countdown message
    display.setTextSize(1);
    int countdown = selectTime - (millis() - lastSwitchTime);
    if (countdown > 0) {
        display.setCursor(startX, 56);
        display.print("Lock in: ");
        display.print(countdown / 1000 + 1); // +1 to show 5, 4, 3... instead of 4, 3, 2...
        display.print("s");
    }
    
    display.display();
}

void drawGameSelectUI(int currentMode){
    
    // Line 1: Player Count (Persists from previous state)
    // The player count is LOCKED, so we draw it static in a smaller font.
    display.clearDisplay(); // Clears the screen before drawing the new UI
    display.setTextSize(1);
    display.setCursor(startX, 0); 
    display.print("P:");
    display.print(playerCount);
    display.print(" | ");
    display.print("Mode Select:");
    
    // Line 2: Current Mode Selection (large)
    display.setTextSize(2);
    display.setCursor(startX, 20); 
    
    // Determine the text to display for the selected mode
    if (currentMode == 1) {
        display.println("1: UNO");
    } else if (currentMode == 2) {
        display.println("2: BLACKJACK");
    } else {
        display.println("3: HOLD'EM"); 
    }
    
    // Line 3: Timeout countdown message
    display.setTextSize(1);
    int countdown = selectTime - (millis() - lastSwitchTime);
    if (countdown > 0) {
        display.setCursor(startX, 50);
        display.print("Lock in: ");
        display.print(countdown / 1000 + 1);
        display.print("s");
    }
    
    display.display();
}

void drawConfigCompleteUI(){
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(WHITE);
    //Print ---Configuration Complete---
    display.setCursor(startX, 0);
    display.println("---Configuration Complete---");
    //Print Player Count
    display.setCursor(startX, 17);
    display.print("Player Count: ");
    display.println(playerCount);
    //Print Game Mode
    display.setCursor(startX, 34);
    display.print("Game Mode: ");
    if(gameMode == 1){
        display.println("UNO");
    } else if(gameMode == 2){
        display.println("BlackJack");
    } else {
        display.println("Texas Hold'em");
    }
    display.display();
}

void drawDispensing(){
    // This function only needs to be called once to display the static message
    static bool drawn = false;
    if (drawn) return;
    
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(4, 24);
    display.println("DISPENSING");
    display.display();
    drawn = true;
}

void sendConfigToNano(){
    if(configSent) return; //Prevent multiple sends
    Wire.beginTransmission(nanoSlaveAddress);
    Wire.write((byte)playerCount);
    Wire.write((byte)gameMode);
    Wire.endTransmission();
    configSent = true;
}